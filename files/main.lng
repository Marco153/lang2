context: struct
{
	alloc : mem_alloc,
	frames : *frame_info,
	frames_count : u32,
	frames_max : u32,
}
DRAW_INFO_HAS_TEXTURE:const s32 = 1;
draw_info: struct
{
	pos :v3,
	pivot :v3,
	ent_size :v3,
	color: [4]f32,
	texture_id : u32,
	cam_size : f32,
	cam_pos :v3,
	flags:u32,
}
key_enum : enum
{
	KEY_LEFT,
	KEY_RIGHT,
	KEY_DOWN,
	KEY_UP,
	KEY_ACT0,
	KEY_ACT1,
	KEY_ACT2,
	KEY_ACT3,
}

clip: struct
{
	tex_idxs: *u32,
	total_texs: u32,
	id:u32,
	len : f32,
	cur_time :f32,
	loop :bool,
}

cel_type: enum
{
	EMPTY,
	SOLID,
	PLAYER,
	TARGET,
}
cel_info :struct
{
	type:cel_type,
}
scene: struct
{
	cels : *cel_info,
	total_cels : u32,
	width : u32,
	height : u32,
	cam_size : f32,
}

player_dir: enum
{
	LEFT,
	RIGHT,
	DOWN,
	UP,
}

frame_action:enum
{
	FREE,
	NOT_ASSIGNED,
	MOV,
}
frame_action_stage:enum
{
	NOT_STARTED,
	DOING,
	DONE,
}
frame_info:struct
{
	type :frame_action,
	stage:frame_action_stage,

	using u :: union
	{
		mov::struct
		{
			from_pos: v3,
			to_pos: v3,
			modify_pos: *v3,
		}
	}
}

IsKeyDown::fn outsider(key_enum) !bool;
IsKeyHeld::fn outsider(key_enum) !bool;
GetTimeSinceStart::fn outsider() !f32;
GetDeltaTime::fn outsider() !f32;
EndFrame::fn outsider(wnd : *u8);

OpenWindow::fn outsider() ! *u8;
ClearBackground::fn outsider(f32, f32, f32);
Draw::fn outsider(*u8, *draw_info);
ShouldClose::fn outsider(*u8) ! bool;
LoadClip::fn outsider(ctx : *context, name:str_lit, x_offset : u32, y_offset:u32, sp_width:u32, sp_height:u32, total_sps :u32, len :f32, out_clip : *clip);

sin::fn outsider(f32) !f32;

UpdateClip::fn(c : *clip, dt : f32) ! u32
{
	c.cur_time += dt;

	if c.cur_time >= c.len
	{
		if c.loop
			c.cur_time = 0.0;
		else
			return *ptr_offset(c.tex_idxs, c.total_texs - 1, u32);
	}

	f: = (cast(f32)c.total_texs * c.cur_time);
	f = f / c.len;

	idx: = *ptr_offset(c.tex_idxs, cast(u32)f, u32);
	return idx;

}
CreateScene::fn(ctx : *context, str : str_lit, scn : *scene, start_pos : *v3)
{
	len: u32= cast(u32)str_ln(str);
	s: = cast(*u8)str;

	width: u32;
	height: u32;

	while* ptr_offset(s, width, char) != '\n
	{
		width++;
	}

	height = len / width;

	scn.cels = cast(*cel_info)heap_alloc(&ctx.alloc, width * height * sizeof(cel_info));
	scn.total_cels = width * height;
	scn.width = width;
	scn.height = height;
	
	i:u32 = 0;

	cel_idx:u64 = 0;
	total_points: = 0;
	while i < len
	{
		x := cel_idx % scn.width;
		y := cast(u32)(cast(f32)i / cast(f32)scn.width);

		ch: = *ptr_offset(s, i, char);
		cur_cel: = ptr_offset(scn.cels, cel_idx, cel_info);
		if ch == '-
		{
			cur_cel.type = cel_type.SOLID;
		}
		else if ch == '.
		{
			cur_cel.type = cel_type.EMPTY;
		}
		else if ch == 't
		{
			cur_cel.type = cel_type.TARGET;
		}
		else if ch == 'p
		{
			cur_cel.type = cel_type.PLAYER;
			start_pos.x = cast(f32)x;
			start_pos.y = -cast(f32)y;
		}
		else if ch == '\n
		{
			cel_idx--;
		}
		else
		{
			__dbg_break;
			cel_idx--;
		}
		cel_idx++;

		i++;
	}

}

ChangeClip::fn(cur_clip : **clip, to : *clip)
{
	to.cur_time = 0.0;
	*cur_clip = to;
}

DrawSceneMap::fn(scn : *scene, window : *u8)
{

	start_x: = 0.0;
	start_y: = 0.0;
	draw: draw_info;
	draw.color = []f32{ 0.0, 0.5, 0.5, 1.0 };
	//draw.flags = draw.flags | DRAW_INFO_HAS_TEXTURE;
	//draw.texture_id = UpdateClip(cur_clip, dt);
	draw.cam_size = scn.cam_size;
	draw.cam_pos.x = 0.0;
	draw.cam_pos.y = 0.0;
	draw.cam_pos.z = 0.0;


	draw.ent_size.x = cast(f32)scn.width;
	draw.ent_size.y = -cast(f32)scn.height;

	//draw.ent_size.y = cast(f32)scn.height;
	draw.pos.x = start_x;
	draw.pos.y = start_y;


	draw.cam_pos.y = 0.0;
	draw.cam_pos.z = 0.0;

	//draw.texture_id = 1;
	Draw(window, &draw);
	//y:s32 = cast(s32)scn.height - 1;
	y:s32 = 0;
	while y < (cast(s32)scn.height)
	{
		x:u32 = 0;
		while x < scn.width
		{
			//x: = i % scn.width;
			//y: = cast(u32)(cast(f32)i / cast(f32)scn.width);
			i: = x + (cast(u32)y * scn.width);

			if ptr_offset(scn.cels, i, cel_info).type == cel_type.SOLID
			{
				draw.color = []f32{ 0.5, 0.0, 0.5, 1.0};
				//draw.flags = draw.flags | DRAW_INFO_HAS_TEXTURE;
				//draw.texture_id = UpdateClip(cur_clip, dt);
				draw.cam_size = scn.cam_size;
				draw.pos.x = cast(f32)x + start_x;
				draw.pos.y = -(cast(f32)y + start_y);
				draw.pos.y -= 1.0;
				draw.pos.z = 0.0;

				draw.ent_size.x = 1.0;
				draw.ent_size.y = 1.0;
				Draw(window, &draw);
			}
			x++;
		}
		y++;
	}
}

ProcessFrameActions::fn(ctx : *context, scn : *scene)
{
	i:u32 = 0;
	while i < ctx.frames_max
	{
		cur_fr: = ptr_offset(ctx.frames, i, frame_info);
		if cur_fr.type == frame_action.MOV
		{
			if cur_fr.stage == frame_action_stage.NOT_STARTED
			{
				dist: = cur_fr.mov.to_pos - cur_fr.mov.from_pos;

				len: = cast(u32)dot_v3(&dist, &dist);

				dst_x: = cast(u32)cur_fr.mov.to_pos.x;
				dst_y: = cast(u32)cur_fr.mov.to_pos.y;

				src_x: = cast(u32)cur_fr.mov.from_pos.x;
				src_y: = cast(u32)cur_fr.mov.from_pos.y;

				sign_dir: = cur_fr.mov.to_pos - cur_fr.mov.from_pos;
				if sign_dir.x > 1.0
					sign_dir.x = 1.0;
				else if sign_dir.x <= -1.0
					sign_dir.x = -1.0;

				if sign_dir.y > 1.0
					sign_dir.y = 1.0;
				else if sign_dir.y <= -1.0
					sign_dir.y = -1.0;

				next_cel_x: = cast(u32)(cur_fr.mov.from_pos.x + sign_dir.x);
				next_cel_y : = cast(u32)(cur_fr.mov.from_pos.y + sign_dir.y);

				src_cel: = ptr_offset(scn.cels, src_x + src_y * scn.width, cel_info);
				dst_cel: = ptr_offset(scn.cels, dst_x + dst_y * scn.width, cel_info);
				next_cel: = ptr_offset(scn.cels, next_cel_x + next_cel_y * scn.width, cel_info);

				if next_cel.type == cel_type.SOLID
				{
					cur_fr.stage = frame_action_stage.DONE;
					*cur_fr.mov.modify_pos = cur_fr.mov.from_pos;

				}
				else
				{
					if dst_cel.type != cel_type.SOLID
					{
						*cur_fr.mov.modify_pos = cur_fr.mov.to_pos;

					}
					else
					{

						*cur_fr.mov.modify_pos = sign_dir + cur_fr.mov.from_pos;
					}
					cur_fr.stage = frame_action_stage.DOING;
				}

				cur_fr.mov.modify_pos.y = -cur_fr.mov.modify_pos.y;
				//dst_cel := ptr_offset(ctx.frames, scr)
				// one block mov
				if len == 1
				{
					
				}
				// two blocks mov
				else if len == 4
				{
					
				}
				else
				{
					// too much blocks mov
					ASSERT(0);
				}
			}
			else if cur_fr.stage == frame_action_stage.DOING
			{
				
			}
			else if cur_fr.stage == frame_action_stage.DONE
			{

			}
			else
				__dbg_break;
		}
		else if cur_fr.type == frame_action.NOT_ASSIGNED || cur_fr.type == frame_action.FREE
		{

		}
		else
			__dbg_break;
		i++;
	}
}
AddFrameAction::fn(ctx : *context) ! *frame_info
{
	i:u32 = 0;
	while i < ctx.frames_max
	{
		cur: = ptr_offset(ctx.frames, i, frame_info);
		if cur.type == frame_action.FREE
		{
			cur.type = frame_action.NOT_ASSIGNED;
			return cur;
		}
		i++;
	}
	ASSERT(0);
	return nil;
}
main :: fn()
{
	ctx: context;
	InitMemAlloc(&ctx.alloc);
	addr: = heap_alloc(&ctx.alloc, 10);
	heap_free(&ctx.alloc, addr);

	ctx.frames_max = 32;
	ctx.frames = cast(*frame_info)heap_alloc(&ctx.alloc, ctx.frames_max * sizeof(frame_info));
	memset(cast(*u8)ctx.frames, 0, sizeof(frame_info));
	
scene1: = 
"---------\n"
"-......--\n"
"-....t..-\n"
"-.p.....-\n"
"---------\n"
;
	window := OpenWindow();

	walk_h:clip;
	LoadClip(&ctx, "../images/frog.png", 32 * 4, 0, 32, 32, 1, 1.0, &walk_h);
	walk_h.loop = false;

	walk_v:clip;
	LoadClip(&ctx, "../images/frog.png", (32 * 3) * 4, 0, 32, 32, 1, 1.0, &walk_v);
	walk_v.loop = false;

	idle_h:clip;
	LoadClip(&ctx, "../images/frog.png", 0, 0, 32, 32, 1, 1.0, &idle_h);
	idle_h.loop = false;

	idle_v:clip;
	LoadClip(&ctx, "../images/frog.png", (32 * 2) * 4, 0, 32, 32, 1, 1.0, &idle_v);
	idle_v.loop = false;

	scn:scene;

	scn.cam_size = 10.0;
	draw:draw_info;
	//pos:v2;
	player_pos:v3;
	player_size:v3;
	final_pos: v3;
	start_pos: v3;
	map_start_pos: v3;
	map_start_pos.x = -4.0;
	map_start_pos.y = 2.0;

	CreateScene(&ctx, scene1, &scn, &player_pos);
	//play

	p_dir: player_dir;
	cur_clip:*clip= &idle_h;
	can_move: = true;

	blocks_jmp: = 2.0;
	player_size.x = 1.0;
	player_size.y = 1.0;

	//start_pos.x += 0.5 + map_start_pos.x;
	//start_pos.y += 0.5 + map_start_pos.y;

	//player_pos.x = 0.5;
	//player_pos.y = 0.5;
	//player_pos.y = 0.0;
	final_pos = player_pos;

	while !ShouldClose(window)
	{
		ClearBackground(0.4, 0.4, 0.5);
		dt: = GetDeltaTime();
		time: = GetTimeSinceStart();
		s: = sin(time) + 1.0;

		DrawSceneMap(&scn, window);

		memset(cast(*u8)& draw, 0, sizeof(draw));

		draw.color = []f32{ 1.0, 0.0, 0.0, 1.0 };
		//*draw.color[1] = 0.0;
		//*draw.color[2] = 0.0;
		//*draw.color[3] = 1.0;
		draw.cam_size = scn.cam_size;
		draw.ent_size.x = 1.0 + s;
		draw.ent_size.y = 1.0 + s;
		draw.pos.x = 0.0;
		draw.pos.y = 0.0;
		draw.pos.z = 0.5;


		//Draw(window, &draw);

		memset(cast(*u8)& draw, 0, sizeof(draw));

		if can_move
		{
			if IsKeyDown(key_enum.KEY_LEFT)
			{
				//__dbg_break;
				player_size.x = -1.0;
				player_size.y = 1.0;
				//final_pos.x -= blocks_jmp;
				//player_pos.x -= dt * 5.0;

				act:= AddFrameAction(&ctx);

				act.type = frame_action.MOV;
				act.mov.from_pos = player_pos;
				act.mov.from_pos.y = -act.mov.from_pos.y;
				//act.mov.from_pos.y = -act.mov.from_pos.y;
				//act.mov.from_pos.x -= map_start_pos.x;
				//act.mov.from_pos.y -= map_start_pos.y;
				act.mov.to_pos.x = player_pos.x - blocks_jmp;
				act.mov.to_pos.y = -player_pos.y;

				//act.mov.to_pos.x -= map_start_pos.x;
				//act.mov.to_pos.y -= map_start_pos.y;
				act.mov.modify_pos = &final_pos;

				p_dir = player_dir.LEFT;
				ChangeClip(&cur_clip, &walk_h);

			}
			else if IsKeyDown(key_enum.KEY_RIGHT)
			{
				player_size.x = 1.0;
				player_size.y = 1.0;
				//player_pos.x += dt * 5.0;
				final_pos.x += blocks_jmp;
				p_dir = player_dir.RIGHT;
				ChangeClip(&cur_clip, &walk_h);
			}
			else if IsKeyDown(key_enum.KEY_UP)
			{
				player_size.x = 1.0;
				player_size.y = 1.0;
				//player_pos.x += dt * 5.0;
				final_pos.y += blocks_jmp;
				p_dir = player_dir.UP;
				ChangeClip(&cur_clip, &walk_v);
			}
			else if IsKeyDown(key_enum.KEY_DOWN)
			{
				player_size.x = 1.0;
				player_size.y = -1.0;
				//player_pos.x += dt * 5.0;
				final_pos.y -= blocks_jmp;
				p_dir = player_dir.DOWN;
				ChangeClip(&cur_clip, &walk_v);
			}
		}

		ProcessFrameActions(&ctx, &scn);
		dir: = final_pos - player_pos;
		d: = dot_v3(&dir, &dir);

		if d > 0.1
		{
			dir = sign_v3(&dir);
			if p_dir == player_dir.LEFT
			{
				player_pos.x -= dt * 4.0;
			}
			else if p_dir == player_dir.RIGHT
			{
				player_pos.x += dt * 4.0;
			}
			else if p_dir == player_dir.DOWN
			{
				player_pos.y -= dt * 4.0;
			}
			else if p_dir == player_dir.UP
			{
				player_pos.y += dt * 4.0;
			}
			//player_pos = player_pos + dir * dt * 4.0;
			can_move = false;
		}
		else
		{
			player_pos = final_pos;
			idle_clip: *clip;
			if p_dir == player_dir.DOWN || p_dir == player_dir.UP
				idle_clip = &idle_v;
			else
				idle_clip = &idle_h;
			ChangeClip(&cur_clip, idle_clip);
			can_move = true;
		}

		//__dbg_break;
		memcpy(&draw.pos, &player_pos, sizeof(draw.pos));
		//draw.pos.x += start_pos.x + map_start_pos.x;
		//draw.pos.y += start_pos.y + map_start_pos.y;
		draw.pos.x += 0.5;
		draw.pos.y -= 0.5;
		memcpy(&draw.ent_size, &player_size, sizeof(draw.ent_size));

		draw.color = []f32{ 1.0, 1.0, 1.0, 1.0};
		draw.flags = draw.flags | DRAW_INFO_HAS_TEXTURE;
		draw.texture_id = UpdateClip(cur_clip, dt);
		draw.cam_size = scn.cam_size;
		draw.cam_pos.x = 0.0;
		draw.cam_pos.y = 0.0;
		draw.cam_pos.z = 0.0;

		draw.pivot.x = 0.5;
		draw.pivot.y = 0.5;
		draw.pivot.z = 0.0;

		draw.cam_pos.y = 0.0;
		draw.cam_pos.z = 0.0;

		//draw.texture_id = 1;
		Draw(window, &draw);
		EndFrame(window);
	}

}
