context: struct
{
	alloc : mem_alloc,
}
DRAW_INFO_HAS_TEXTURE:const s32 = 1;
draw_info: struct
{
	pos :v3,
	pivot :v3,
	ent_size :v3,
	color: [4]f32,
	texture_id : u32,
	cam_size : f32,
	cam_pos :v3,
	flags:u32,
}
key_enum : enum
{
	KEY_LEFT,
	KEY_RIGHT,
	KEY_DOWN,
	KEY_UP,
	KEY_ACT0,
	KEY_ACT1,
	KEY_ACT2,
	KEY_ACT3,
}

clip: struct
{
	tex_idxs: *u32,
	total_texs: u32,
	id:u32,
	len : f32,
	cur_time :f32,
	loop :bool,
}
cel_type: enum
{
	EMPTY,
	SOLID,
	PLAYER,
	TARGET,
}
cel_info :struct
{
	type:cel_type,
}
scene: struct
{
	cels : *cel_info,
	total_cels : u32,
	width : u32,
	height : u32,
	cam_size : f32,
}

player_dir: enum
{
	LEFT,
	RIGHT,
	DOWN,
	UP,
}
IsKeyDown::fn outsider(key_enum) !bool;
IsKeyHeld::fn outsider(key_enum) !bool;
GetTimeSinceStart::fn outsider() !f32;
GetDeltaTime::fn outsider() !f32;
EndFrame::fn outsider(wnd : *u8);

OpenWindow::fn outsider() ! *u8;
ClearBackground::fn outsider(f32, f32, f32);
Draw::fn outsider(*u8, *draw_info);
ShouldClose::fn outsider(*u8) ! bool;
LoadClip::fn outsider(ctx : *context, name:str_lit, x_offset : u32, y_offset:u32, sp_width:u32, sp_height:u32, total_sps :u32, len :f32, out_clip : *clip);

sin::fn outsider(f32) !f32;

UpdateClip::fn(c : *clip, dt : f32) ! u32
{
	c.cur_time += dt;

	if c.cur_time >= c.len
	{
		if c.loop
			c.cur_time = 0.0;
		else
			return *ptr_offset(c.tex_idxs, c.total_texs - 1, u32);
	}

	f: = (cast(f32)c.total_texs * c.cur_time);
	f = f / c.len;

	idx: = *ptr_offset(c.tex_idxs, cast(u32)f, u32);
	return idx;

}
CreateScene::fn(ctx : *context, str : str_lit, scn : *scene, start_pos : *v3)
{
	len: u32= cast(u32)str_ln(str);
	s: = cast(*u8)str;

	width: u32;
	height: u32;

	while* ptr_offset(s, width, char) != '\n
	{
		width++;
	}

	height = len / width;

	scn.cels = cast(*cel_info)heap_alloc(&ctx.alloc, width * height * sizeof(cel_info));
	scn.total_cels = width * height;
	scn.width = width;
	scn.height = height;
	
	i:u32 = 0;

	cel_idx:u64 = 0;
	total_points: = 0;
	while i < len
	{
		x := cel_idx % scn.width;
		y := cast(u32)(cast(f32)i / cast(f32)scn.width);

		ch: = *ptr_offset(s, i, char);
		cur_cel: = ptr_offset(scn.cels, cel_idx, cel_info);
		if ch == '-
		{
			cur_cel.type = cel_type.SOLID;
		}
		else if ch == '.
		{
			cur_cel.type = cel_type.EMPTY;
		}
		else if ch == 't
		{
			cur_cel.type = cel_type.TARGET;
		}
		else if ch == 'p
		{
			cur_cel.type = cel_type.PLAYER;
			start_pos.x = cast(f32)x;
			start_pos.y = cast(f32)y;
		}
		else if ch == '\n
		{
			cel_idx--;
		}
		else
		{
			__dbg_break;
			cel_idx--;
		}
		cel_idx++;

		i++;
	}

}

ChangeClip::fn(cur_clip : **clip, to : *clip)
{
	to.cur_time = 0.0;
	*cur_clip = to;
}

DrawSceneMap::fn(scn : *scene, window : *u8)
{

	draw: draw_info;
	draw.color = []f32{ 0.0, 0.5, 0.5, 1.0};
	//draw.flags = draw.flags | DRAW_INFO_HAS_TEXTURE;
	//draw.texture_id = UpdateClip(cur_clip, dt);
	draw.cam_size = scn.cam_size;
	draw.cam_pos.x = 0.0;
	draw.cam_pos.y = 0.0;
	draw.cam_pos.z = 0.0;

	draw.ent_size.x = cast(f32)scn.width;
	draw.ent_size.y = cast(f32)scn.height;


	draw.cam_pos.y = 0.0;
	draw.cam_pos.z = 0.0;

	//draw.texture_id = 1;
	Draw(window, &draw);
	i:u32 = 0;
	while i < scn.width * scn.height
	{
		x := i % scn.width;
		y := cast(u32)(cast(f32)i / cast(f32)scn.width);

		if ptr_offset(scn.cels, i, cel_info).type == cel_type.SOLID
		{
			draw.color = []f32{ 0.5, 0.0, 0.5, 1.0};
			//draw.flags = draw.flags | DRAW_INFO_HAS_TEXTURE;
			//draw.texture_id = UpdateClip(cur_clip, dt);
			draw.cam_size = scn.cam_size;
			draw.pos.x = cast(f32)x;
			draw.pos.y = cast(f32)y;
			draw.pos.z = 0.0;

			draw.ent_size.x = 1.0;
			draw.ent_size.y = 1.0;
			Draw(window, &draw);
		}
		i++;
	}
}

main :: fn()
{
	ctx: context;
	InitMemAlloc(&ctx.alloc);
	addr: = heap_alloc(&ctx.alloc, 10);
	heap_free(&ctx.alloc, addr);
	
scene1: = 
"---------\n"
"--......-\n"
"-....t..-\n"
"-...p...-\n"
"---------\n"
;
	window := OpenWindow();

	walk_h:clip;
	LoadClip(&ctx, "../images/frog.png", 32 * 4, 0, 32, 32, 1, 1.0, &walk_h);
	walk_h.loop = false;

	walk_v:clip;
	LoadClip(&ctx, "../images/frog.png", (32 * 3) * 4, 0, 32, 32, 1, 1.0, &walk_v);
	walk_v.loop = false;

	idle_h:clip;
	LoadClip(&ctx, "../images/frog.png", 0, 0, 32, 32, 1, 1.0, &idle_h);
	idle_h.loop = false;

	idle_v:clip;
	LoadClip(&ctx, "../images/frog.png", (32 * 2) * 4, 0, 32, 32, 1, 1.0, &idle_v);
	idle_v.loop = false;

	scn:scene;

	scn.cam_size = 5.0;
	draw:draw_info;
	//pos:v2;
	player_pos:v3;
	player_size:v3;
	final_pos: v3;
	start_pos: v3;

	CreateScene(&ctx, scene1, &scn, &start_pos);

	p_dir: player_dir;
	cur_clip:*clip= &idle_h;
	can_move: = true;

	blocks_jmp: = 2.0;
	player_size.x = 1.0;
	player_size.y = 1.0;

	start_pos.x += 0.5;
	start_pos.y += 0.5;

	//final_pos.x = 0.5;
	//final_pos.y = 0.5;

	while !ShouldClose(window)
	{
		ClearBackground(0.4, 0.4, 0.5);
		dt: = GetDeltaTime();
		time: = GetTimeSinceStart();
		s: = sin(time) + 1.0;

		DrawSceneMap(&scn, window);

		memset(cast(*u8)& draw, 0, sizeof(draw));

		draw.color = []f32{ 1.0, 0.0, 0.0, 1.0 };
		//*draw.color[1] = 0.0;
		//*draw.color[2] = 0.0;
		//*draw.color[3] = 1.0;
		draw.cam_size = scn.cam_size;
		draw.ent_size.x = 1.0 + s;
		draw.ent_size.y = 1.0 + s;
		draw.pos.x = 0.0;
		draw.pos.y = 0.0;
		draw.pos.z = 0.5;


		//Draw(window, &draw);

		memset(cast(*u8)& draw, 0, sizeof(draw));

		if can_move
		{
			if IsKeyDown(key_enum.KEY_LEFT)
			{
				player_size.x = -1.0;
				player_size.y = 1.0;
				final_pos.x -= blocks_jmp;
				//player_pos.x -= dt * 5.0;
				p_dir = player_dir.LEFT;
				ChangeClip(&cur_clip, &walk_h);

			}
			else if IsKeyDown(key_enum.KEY_RIGHT)
			{
				player_size.x = 1.0;
				player_size.y = 1.0;
				//player_pos.x += dt * 5.0;
				final_pos.x += blocks_jmp;
				p_dir = player_dir.RIGHT;
				ChangeClip(&cur_clip, &walk_h);
			}
			else if IsKeyDown(key_enum.KEY_UP)
			{
				player_size.x = 1.0;
				player_size.y = 1.0;
				//player_pos.x += dt * 5.0;
				final_pos.y += blocks_jmp;
				p_dir = player_dir.UP;
				ChangeClip(&cur_clip, &walk_v);
			}
			else if IsKeyDown(key_enum.KEY_DOWN)
			{
				player_size.x = 1.0;
				player_size.y = -1.0;
				//player_pos.x += dt * 5.0;
				final_pos.y -= blocks_jmp;
				p_dir = player_dir.DOWN;
				ChangeClip(&cur_clip, &walk_v);
			}
		}
		dir: = final_pos - player_pos;
		d: = dot_v3(&dir, &dir);

		if d > 0.01
		{
			dir = sign_v3(&dir);
			if p_dir == player_dir.LEFT
			{
				player_pos.x -= dt * 4.0;
			}
			else if p_dir == player_dir.RIGHT
			{
				player_pos.x += dt * 4.0;
			}
			else if p_dir == player_dir.DOWN
			{
				player_pos.y -= dt * 4.0;
			}
			else if p_dir == player_dir.UP
			{
				player_pos.y += dt * 4.0;
			}
			//player_pos = player_pos + dir * dt * 4.0;
			can_move = false;
		}
		else
		{
			player_pos = final_pos;
			idle_clip: *clip;
			if p_dir == player_dir.DOWN || p_dir == player_dir.UP
				idle_clip = &idle_v;
			else
				idle_clip = &idle_h;
			ChangeClip(&cur_clip, idle_clip);
			can_move = true;
		}


		memcpy(&draw.pos, &player_pos, sizeof(draw.pos));
		draw.pos.x += start_pos.x;
		draw.pos.y += start_pos.y;
		//draw.pos.x += 0.5;
		//draw.pos.y += 0.5;
		memcpy(&draw.ent_size, &player_size, sizeof(draw.ent_size));

		draw.color = []f32{ 1.0, 1.0, 1.0, 1.0};
		draw.flags = draw.flags | DRAW_INFO_HAS_TEXTURE;
		draw.texture_id = UpdateClip(cur_clip, dt);
		draw.cam_size = scn.cam_size;
		draw.cam_pos.x = 0.0;
		draw.cam_pos.y = 0.0;
		draw.cam_pos.z = 0.0;

		draw.pivot.x = 0.5;
		draw.pivot.y = 0.5;
		draw.pivot.z = 0.0;

		draw.cam_pos.y = 0.0;
		draw.cam_pos.z = 0.0;

		//draw.texture_id = 1;
		Draw(window, &draw);
		EndFrame(window);
	}

}
